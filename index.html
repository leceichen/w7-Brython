<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>多機器人蛇形路徑模擬</title>
    <script src="https://cdn.jsdelivr.net/npm/brython@3/brython.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/brython@3/brython_stdlib.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 {
            color: #333;
            text-align: center;
        }
        #brython_div1 {
            margin: 20px 0;
            border: 2px solid #333;
            border-radius: 4px;
        }
        .info {
            background: #e8f4fd;
            padding: 15px;
            border-radius: 4px;
            margin: 15px 0;
        }
        .legend {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 15px 0;
        }
        .color-sample {
            display: inline-block;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            margin-right: 8px;
            vertical-align: middle;
        }
        .blue { background-color: #0000FF; }
        .red { background-color: #FF0000; }
        .green { background-color: #00AA00; }
    </style>
</head>
<body onload="brython()">
    <div class="container">
        <h1>多機器人蛇形路徑模擬</h1>
        
        <div class="info">
            <p>這個模擬展示了三個機器人在網格世界中按照蛇形路徑移動：</p>
            <ul>
                <li><span class="color-sample blue"></span> 藍色機器人：掃描上半區域 (行 0-6)</li>
                <li><span class="color-sample red"></span> 紅色機器人：掃描中間區域 (行 7-13)</li>
                <li><span class="color-sample green"></span> 綠色機器人：掃描下半區域 (行 14-19)</li>
            </ul>
            <p>每個機器人按照蛇形模式（來回掃描）覆蓋其分配的區域。</p>
        </div>

        <div id="brython_div1"></div>
        
        <div class="legend">
            <div><span class="color-sample blue"></span> 藍色機器人</div>
            <div><span class="color-sample red"></span> 紅色機器人</div>
            <div><span class="color-sample green"></span> 綠色機器人</div>
        </div>
    </div>

    <script type="text/python">
from browser import document, html, timer

CELL_SIZE = 30
WALL_THICKNESS = 6
IMG_PATH = "https://mde.tw/cp2025/reeborg/src/images/"

# ------------------ 世界 ------------------
class World:
    def __init__(self, width, height):
        self.width = width
        self.height = height
        self.layers = {
            "grid": html.CANVAS(width=self.width*CELL_SIZE, height=self.height*CELL_SIZE),
            "walls": html.CANVAS(width=self.width*CELL_SIZE, height=self.height*CELL_SIZE),
            "objects": html.CANVAS(width=self.width*CELL_SIZE, height=self.height*CELL_SIZE),
            "robots_container": html.DIV()
        }
        self._init_html()
        self._draw_grid()
        self._draw_walls()

    def _init_html(self):
        container = html.DIV(style={
            "position": "relative",
            "width": f"{self.width*CELL_SIZE}px",
            "height": f"{self.height*CELL_SIZE}px",
            "border": "2px solid #000"
        })
        for z, key in enumerate(["grid","walls","objects"]):
            canvas = self.layers[key]
            canvas.style = {"position":"absolute","top":"0px","left":"0px","zIndex":str(z)}
            container <= canvas
        # robots container 最上層
        self.layers["robots_container"].style = {
            "position":"absolute","top":"0px","left":"0px",
            "width":f"{self.width*CELL_SIZE}px",
            "height":f"{self.height*CELL_SIZE}px",
            "zIndex":"100"
        }
        container <= self.layers["robots_container"]
        document["brython_div1"].clear()
        document["brython_div1"] <= container

    def _draw_grid(self):
        ctx = self.layers["grid"].getContext("2d")
        ctx.strokeStyle = "#cccccc"
        for i in range(self.width+1):
            ctx.beginPath()
            ctx.moveTo(i*CELL_SIZE,0)
            ctx.lineTo(i*CELL_SIZE,self.height*CELL_SIZE)
            ctx.stroke()
        for j in range(self.height+1):
            ctx.beginPath()
            ctx.moveTo(0,j*CELL_SIZE)
            ctx.lineTo(self.width*CELL_SIZE,j*CELL_SIZE)
            ctx.stroke()

    def _draw_image(self, ctx, src, x, y, w, h, offset_x=0, offset_y=0):
        img = html.IMG()
        img.src = src
        def onload(evt):
            px = x*CELL_SIZE + offset_x
            py = (self.height-1-y)*CELL_SIZE + offset_y
            ctx.drawImage(img, px, py, w, h)
        img.bind("load", onload)

    def _draw_walls(self):
        ctx = self.layers["walls"].getContext("2d")
        for x in range(self.width):
            self._draw_image(ctx, IMG_PATH+"north.png", x, self.height-1, CELL_SIZE, WALL_THICKNESS)
            self._draw_image(ctx, IMG_PATH+"north.png", x, 0, CELL_SIZE, WALL_THICKNESS, offset_y=CELL_SIZE-WALL_THICKNESS)
        for y in range(self.height):
            self._draw_image(ctx, IMG_PATH+"east.png", 0, y, WALL_THICKNESS, CELL_SIZE)
            self._draw_image(ctx, IMG_PATH+"east.png", self.width-1, y, WALL_THICKNESS, CELL_SIZE, offset_x=CELL_SIZE-WALL_THICKNESS)

# ------------------ Robot ------------------
class AnimatedRobot:
    # 為每個機器人分配唯一的 z-index
    next_zindex = 1000

    def __init__(self, world, start_pos, color="blue"):
        self.world = world
        self.x, self.y = start_pos
        self.color = color
        self.trace_ctx = world.layers["objects"].getContext("2d")
        self.queue = []
        self.running = False

        # 為每個機器人分配唯一的 z-index
        self.zindex = AnimatedRobot.next_zindex
        AnimatedRobot.next_zindex += 1

        # robot canvas 單獨建立
        self.robot_canvas = html.CANVAS(width=self.world.width*CELL_SIZE,
                                        height=self.world.height*CELL_SIZE)
        self.robot_canvas.style = {
            "position":"absolute",
            "top":"0px",
            "left":"0px",
            "zIndex":str(self.zindex),
            "pointerEvents": "none"
        }
        self.world.layers["robots_container"] <= self.robot_canvas
        self.robot_ctx = self.robot_canvas.getContext("2d")

        # 立即繪製初始位置的機器人
        self._draw_robot()

    def _draw_robot(self):
        self.robot_ctx.clearRect(0, 0, self.world.width*CELL_SIZE, self.world.height*CELL_SIZE)
        
        # 使用彩色圓形作為機器人
        colors = {
            "blue": "#0000FF", 
            "red": "#FF0000", 
            "green": "#00AA00"
        }
        
        x_px = self.x * CELL_SIZE + CELL_SIZE // 2
        y_px = (self.world.height - 1 - self.y) * CELL_SIZE + CELL_SIZE // 2
        radius = CELL_SIZE // 3
        
        # 繪製圓形
        self.robot_ctx.fillStyle = colors[self.color]
        self.robot_ctx.beginPath()
        self.robot_ctx.arc(x_px, y_px, radius, 0, 2 * 3.14159)
        self.robot_ctx.fill()
        
        # 添加白色邊框
        self.robot_ctx.strokeStyle = "white"
        self.robot_ctx.lineWidth = 2
        self.robot_ctx.stroke()

    def _draw_trace(self, fx, fy, tx, ty):
        ctx = self.trace_ctx
        colors = {
            "blue": "#0000FF", 
            "red": "#FF0000", 
            "green": "#00AA00"
        }
        ctx.strokeStyle = colors[self.color]
        ctx.lineWidth = 3
        ctx.beginPath()
        ctx.moveTo(fx*CELL_SIZE+CELL_SIZE/2, (self.world.height-1-fy)*CELL_SIZE+CELL_SIZE/2)
        ctx.lineTo(tx*CELL_SIZE+CELL_SIZE/2, (self.world.height-1-ty)*CELL_SIZE+CELL_SIZE/2)
        ctx.stroke()

    def follow_path(self, path):
        def action(next_done):
            idx = 0
            def step():
                nonlocal idx
                if idx >= len(path):
                    next_done()
                    return
                
                # 更新位置
                prev_x, prev_y = self.x, self.y
                self.x, self.y = path[idx]
                
                # 繪製軌跡和機器人
                if idx > 0:  # 從第一步開始畫軌跡
                    self._draw_trace(prev_x, prev_y, self.x, self.y)
                self._draw_robot()
                
                idx += 1
                timer.set_timeout(step, 150)  # 調整速度
            step()
        self.queue.append(action)
        self._run_queue()

    def _run_queue(self):
        if self.running or not self.queue:
            return
        self.running = True
        action = self.queue.pop(0)
        action(lambda:self._done())

    def _done(self):
        self.running = False
        self._run_queue()

# ------------------ 蛇形路徑 ------------------
def snake_path(x_start, x_end, y_start, y_end):
    path = []
    for y in range(y_start, y_end + 1):
        # 根據行號決定移動方向
        if (y - y_start) % 2 == 0:
            # 偶數行：從左到右
            for x in range(x_start, x_end + 1):
                path.append((x, y))
        else:
            # 奇數行：從右到左
            for x in range(x_end, x_start - 1, -1):
                path.append((x, y))
    return path

# ------------------ 建立世界 & robot ------------------
w = World(20, 20)

# 定義三個機器人的蛇形路徑區域
paths = [
    snake_path(0, 19, 0, 6),    # 藍色：從第0行到第6行
    snake_path(0, 19, 7, 13),   # 紅色：從第7行到第13行
    snake_path(0, 19, 14, 19)   # 綠色：從第14行到第19行
]

robots_instances = [
    AnimatedRobot(w, paths[0][0], "blue"),
    AnimatedRobot(w, paths[1][0], "red"), 
    AnimatedRobot(w, paths[2][0], "green")
]

# ------------------ 開始移動 ------------------
# 讓所有機器人同時開始移動
for robot, path in zip(robots_instances, paths):
    robot.follow_path(path)
    </script>
</body>
</html>

